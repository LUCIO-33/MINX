;=================================================================================
;                                                                                =
;                                      MINX                                      =
;                                                                                =
;=================================================================================
;                                                                                =
;                            Jet Propulsion Laboratory                           =
;                                      MISR                                      =
;                                                                                =
;            Copyright 2007-2019, California Institute of Technology.            =
;                              ALL RIGHTS RESERVED.                              =
;                    U.S. Government Sponsorship acknowledged.                   =
;                                                                                =
;                                                                                =
;=================================================================================

;*********************************************************************************
PRO GetSwathLatLonCoords, Path, BlkBeg, BlkEnd, WrapLon, LatLonCoords
;*********************************************************************************
; Define the REDUCED Lat-Lon coordinates of the corners of all 180 MISR blocks.
; These are represented by smoothed lines at the left and right edges approximately
; at swath edges (i.e. where good data values are present in the An camera).
; Every MISR path has identical latitude block corner coordinates, so they are
; needed just once. Every MISR path has identical longitude block corner coords
; shifted by a constant number of degrees, so they are needed just once also. The
; values below are for Path 1.
; WrapLon: wrap longitude values by adding 360 when they reach this negative value.
;---------------------------------------------------------------------------------

COMPILE_OPT idl2, LOGICAL_PREDICATE, STRICTARRSUBS

;---------------------------------------------------------------------------------
; Table of geographic coordinates of smoothed swath corners per block.
;---------------------------------------------------------------------------------

;     Lon UL      Lat UL      Lon LL       Lat LL       Lon LR      Lat LR       Lon UR      Lat UR
;   ---------    --------    ---------    --------     --------    --------     --------    --------

LLSwathCoords = $                                                                                           ; BLOCK
[[  108.79248D,  66.05179D,  107.95461D,  67.26924D,   98.85894D,  65.96501D,  100.06163D,  64.80687D],  $  ;   1
 [  107.95461D,  67.26924D,  106.95266D,  68.47348D,   97.47176D,  67.09970D,   98.85894D,  65.96501D],  $
 [  106.95266D,  68.47348D,  105.81383D,  69.66820D,   95.92312D,  68.21614D,   97.47175D,  67.09970D],  $
 [  105.81383D,  69.66820D,  104.54247D,  70.85481D,   94.21478D,  69.31607D,   95.92312D,  68.21614D],  $
 [  104.54246D,  70.85481D,  103.11343D,  72.03175D,   92.32287D,  70.39674D,   94.21478D,  69.31607D],  $
 [  103.11343D,  72.03175D,  101.46364D,  73.19342D,   90.19327D,  71.44955D,   92.32287D,  70.39674D],  $
 [  101.46364D,  73.19342D,   99.61486D,  74.34422D,   87.84493D,  72.48066D,   90.19327D,  71.44955D],  $
 [   99.61486D,  74.34422D,   97.45105D,  75.47323D,   85.18730D,  73.47420D,   87.84493D,  72.48066D],  $
 [   97.45104D,  75.47324D,   94.97627D,  76.58409D,   82.23229D,  74.43559D,   85.18731D,  73.47419D],  $
 [   94.97627D,  76.58409D,   92.07366D,  77.66699D,   78.90550D,  75.35186D,   82.23229D,  74.43559D],  $  ;  10
 [   92.07366D,  77.66699D,   88.71980D,  78.72487D,   75.21289D,  76.22843D,   78.90550D,  75.35186D],  $
 [   88.71980D,  78.72487D,   84.65849D,  79.73200D,   71.01758D,  77.03436D,   75.21289D,  76.22843D],  $
 [   84.65849D,  79.73200D,   79.75879D,  80.67860D,   66.30189D,  77.76381D,   71.01758D,  77.03436D],  $
 [   79.75878D,  80.67860D,   73.86510D,  81.55168D,   61.05903D,  78.41097D,   66.30188D,  77.76381D],  $
 [   73.86510D,  81.55168D,   66.72256D,  82.31810D,   55.25637D,  78.95237D,   61.05903D,  78.41097D],  $
 [   66.72256D,  82.31810D,   58.21154D,  82.95186D,   48.94795D,  79.38126D,   55.25637D,  78.95237D],  $
 [   58.21154D,  82.95186D,   48.27174D,  83.39572D,   42.19059D,  79.66430D,   48.94795D,  79.38126D],  $
 [   48.27174D,  83.39572D,   37.29523D,  83.62952D,   35.16088D,  79.80894D,   42.19059D,  79.66430D],  $
 [   37.29523D,  83.62952D,   25.92967D,  83.62033D,   28.03831D,  79.79949D,   35.16088D,  79.80894D],  $
 [   25.92967D,  83.62033D,   14.98902D,  83.37858D,   21.02411D,  79.64605D,   28.03831D,  79.79949D],  $  ;  20
 [   14.98902D,  83.37858D,    5.13602D,  82.91926D,   14.30788D,  79.34545D,   21.02411D,  79.64605D],  $
 [    5.13602D,  82.91926D,   -3.35654D,  82.28920D,    8.01554D,  78.91866D,   14.30788D,  79.34545D],  $
 [   -3.35654D,  82.28920D,  -10.45058D,  81.51899D,    2.24768D,  78.37094D,    8.01554D,  78.91866D],  $
 [  -10.45058D,  81.51899D,  -16.34858D,  80.64984D,   -2.98632D,  77.72659D,    2.24768D,  78.37094D],  $
 [  -16.34858D,  80.64984D,  -21.17144D,  79.69461D,   -7.64281D,  76.98456D,   -2.98632D,  77.72659D],  $
 [  -21.17144D,  79.69461D,  -25.20739D,  78.68606D,  -11.80781D,  76.17499D,   -7.64281D,  76.98456D],  $
 [  -25.20739D,  78.68606D,  -28.62059D,  77.63719D,  -15.52996D,  75.30898D,  -11.80781D,  76.17499D],  $
 [  -28.62058D,  77.63719D,  -31.50298D,  76.55275D,  -18.83237D,  74.38950D,  -15.52996D,  75.30898D],  $
 [  -31.50298D,  76.55275D,  -33.99621D,  75.44491D,  -21.79302D,  73.43140D,  -18.83237D,  74.38950D],  $
 [  -33.99621D,  75.44491D,  -36.14370D,  74.31463D,  -24.43046D,  72.43529D,  -21.79302D,  73.43140D],  $  ;  30
 [  -36.14370D,  74.31463D,  -38.01015D,  73.16638D,  -26.78690D,  71.40725D,  -24.43046D,  72.43529D],  $
 [  -38.01015D,  73.16638D,  -39.70589D,  72.01041D,  -28.95006D,  70.36225D,  -26.78691D,  71.40725D],  $
 [  -39.70589D,  72.01041D,  -41.17648D,  70.83841D,  -30.87400D,  69.28858D,  -28.95006D,  70.36225D],  $
 [  -41.17648D,  70.83841D,  -42.48538D,  69.65617D,  -32.61257D,  68.19494D,  -30.87400D,  69.28858D],  $
 [  -42.48538D,  69.65617D,  -43.68392D,  68.46814D,  -34.21244D,  67.08839D,  -32.61257D,  68.19494D],  $
 [  -43.68392D,  68.46814D,  -44.76470D,  67.27251D,  -35.66963D,  65.96663D,  -34.21244D,  67.08839D],  $
 [  -44.76470D,  67.27251D,  -45.76831D,  66.07290D,  -37.02300D,  64.83546D,  -35.66963D,  65.96663D],  $
 [  -45.76831D,  66.07290D,  -46.66085D,  64.86505D,  -38.24418D,  63.68876D,  -37.02301D,  64.83546D],  $
 [  -46.66085D,  64.86505D,  -47.52170D,  63.65688D,  -39.40814D,  62.53887D,  -38.24418D,  63.68876D],  $
 [  -47.52170D,  63.65688D,  -48.31403D,  62.44402D,  -40.48348D,  61.37943D,  -39.40814D,  62.53887D],  $  ;  40
 [  -48.31403D,  62.44402D,  -49.04636D,  61.22704D,  -41.47996D,  60.21154D,  -40.48348D,  61.37943D],  $
 [  -49.04636D,  61.22704D,  -49.74518D,  60.00837D,  -42.42430D,  59.03913D,  -41.47995D,  60.21154D],  $
 [  -49.74518D,  60.00837D,  -50.39601D,  58.78627D,  -43.30459D,  57.85972D,  -42.42430D,  59.03913D],  $
 [  -50.39601D,  58.78627D,  -51.00422D,  57.56110D,  -44.12734D,  56.67404D,  -43.30459D,  57.85972D],  $
 [  -51.00422D,  57.56111D,  -51.59195D,  56.33489D,  -44.91502D,  55.48535D,  -44.12734D,  56.67405D],  $
 [  -51.59195D,  56.33489D,  -52.12766D,  55.10440D,  -45.63869D,  54.28881D,  -44.91502D,  55.48535D],  $
 [  -52.12766D,  55.10440D,  -52.64939D,  53.87322D,  -46.33589D,  53.09006D,  -45.63869D,  54.28880D],  $
 [  -52.64939D,  53.87322D,  -53.15881D,  52.64138D,  -47.00934D,  51.88924D,  -46.33589D,  53.09006D],  $
 [  -53.15882D,  52.64137D,  -53.64178D,  51.40741D,  -47.64632D,  50.68422D,  -47.00934D,  51.88924D],  $
 [  -53.64178D,  51.40741D,  -54.08556D,  50.17009D,  -48.23523D,  49.47318D,  -47.64633D,  50.68422D],  $  ;  50
 [  -54.08556D,  50.17009D,  -54.52318D,  48.93246D,  -48.80884D,  48.26085D,  -48.23523D,  49.47318D],  $
 [  -54.52318D,  48.93246D,  -54.95550D,  47.69448D,  -49.36871D,  47.04726D,  -48.80884D,  48.26085D],  $
 [  -54.95550D,  47.69447D,  -55.36909D,  46.45487D,  -49.90238D,  45.83053D,  -49.36871D,  47.04726D],  $
 [  -55.36909D,  46.45487D,  -55.76557D,  45.21375D,  -50.41196D,  44.61086D,  -49.90238D,  45.83053D],  $
 [  -55.76557D,  45.21375D,  -56.14639D,  43.97125D,  -50.89933D,  43.38850D,  -50.41196D,  44.61086D],  $
 [  -56.14639D,  43.97124D,  -56.51285D,  42.72743D,  -51.36622D,  42.16362D,  -50.89933D,  43.38850D],  $
 [  -56.51285D,  42.72744D,  -56.89229D,  41.48463D,  -51.83990D,  40.93976D,  -51.36622D,  42.16361D],  $
 [  -56.89229D,  41.48464D,  -57.24580D,  40.23948D,  -52.28254D,  39.71187D,  -51.83990D,  40.93976D],  $
 [  -57.24580D,  40.23948D,  -57.58773D,  38.99320D,  -52.70853D,  38.48184D,  -52.28254D,  39.71187D],  $
 [  -57.58773D,  38.99320D,  -57.93139D,  37.74689D,  -53.13133D,  37.25133D,  -52.70853D,  38.48184D],  $  ;  60
 [  -57.93139D,  37.74689D,  -58.26482D,  36.49954D,  -53.53942D,  36.01885D,  -53.13133D,  37.25132D],  $
 [  -58.26482D,  36.49954D,  -58.60082D,  35.25217D,  -53.94573D,  34.78594D,  -53.53942D,  36.01885D],  $
 [  -58.60082D,  35.25217D,  -58.91591D,  34.00290D,  -54.32726D,  33.54985D,  -53.94573D,  34.78595D],  $
 [  -58.91591D,  34.00290D,  -59.23464D,  32.75369D,  -54.70851D,  32.31346D,  -54.32726D,  33.54985D],  $
 [  -59.23464D,  32.75369D,  -59.54564D,  31.50363D,  -55.07844D,  31.07546D,  -54.70851D,  32.31346D],  $
 [  -59.54564D,  31.50364D,  -59.86088D,  30.25366D,  -55.44909D,  29.83721D,  -55.07844D,  31.07547D],  $
 [  -59.86088D,  30.25366D,  -60.16927D,  29.00291D,  -55.80963D,  28.59748D,  -55.44909D,  29.83722D],  $
 [  -60.16927D,  29.00292D,  -60.47134D,  27.75144D,  -56.16075D,  27.35634D,  -55.80963D,  28.59748D],  $
 [  -60.47134D,  27.75144D,  -60.76758D,  26.49929D,  -56.50308D,  26.11388D,  -56.16075D,  27.35634D],  $
 [  -60.76758D,  26.49929D,  -61.05848D,  25.24650D,  -56.83722D,  24.87017D,  -56.50308D,  26.11387D],  $  ;  70
 [  -61.05848D,  25.24650D,  -61.34447D,  23.99313D,  -57.16370D,  23.62530D,  -56.83721D,  24.87017D],  $
 [  -61.34447D,  23.99314D,  -61.62596D,  22.73923D,  -57.48306D,  22.37934D,  -57.16370D,  23.62530D],  $
 [  -61.62596D,  22.73923D,  -61.90335D,  21.48483D,  -57.79577D,  21.13234D,  -57.48306D,  22.37933D],  $
 [  -61.90335D,  21.48483D,  -62.17699D,  20.22998D,  -58.10229D,  19.88437D,  -57.79577D,  21.13234D],  $
 [  -62.17699D,  20.22997D,  -62.44723D,  18.97470D,  -58.40306D,  18.63550D,  -58.10229D,  19.88438D],  $
 [  -62.44723D,  18.97470D,  -62.71441D,  17.71904D,  -58.69846D,  17.38578D,  -58.40306D,  18.63550D],  $
 [  -62.71441D,  17.71905D,  -62.97884D,  16.46305D,  -58.98889D,  16.13527D,  -58.69846D,  17.38578D],  $
 [  -62.97884D,  16.46305D,  -63.24082D,  15.20675D,  -59.27472D,  14.88401D,  -58.98889D,  16.13527D],  $
 [  -63.24082D,  15.20675D,  -63.50064D,  13.95019D,  -59.55627D,  13.63205D,  -59.27472D,  14.88401D],  $
 [  -63.50064D,  13.95019D,  -63.76867D,  12.69412D,  -59.84396D,  12.38034D,  -59.55627D,  13.63205D],  $  ;  80
 [  -63.76867D,  12.69412D,  -64.03500D,  11.43786D,  -60.12793D,  11.12798D,  -59.84396D,  12.38033D],  $
 [  -64.03500D,  11.43786D,  -64.30989D,  10.18216D,  -60.41849D,   9.87590D,  -60.12793D,  11.12799D],  $
 [  -64.30989D,  10.18217D,  -64.57359D,   8.92561D,  -60.69594D,   8.62241D,  -60.41849D,   9.87590D],  $
 [  -64.57359D,   8.92561D,  -64.84632D,   7.66970D,  -60.98052D,   7.36925D,  -60.69594D,   8.62240D],  $
 [  -64.84632D,   7.66970D,  -65.10844D,   6.41301D,  -61.25263D,   6.11481D,  -60.98052D,   7.36925D],  $
 [  -65.10845D,   6.41301D,  -65.37019D,   5.15632D,  -61.52251D,   4.85997D,  -61.25263D,   6.11481D],  $
 [  -65.37019D,   5.15632D,  -65.64168D,   3.90038D,  -61.80029D,   3.60556D,  -61.52251D,   4.85998D],  $
 [  -65.64167D,   3.90038D,  -65.90339D,   2.64378D,  -62.06649D,   2.35003D,  -61.80029D,   3.60556D],  $
 [  -65.90339D,   2.64378D,  -66.17532D,   1.38803D,  -62.34109D,   1.09499D,  -62.06649D,   2.35003D],  $
 [  -66.17532D,   1.38803D,  -66.43801D,   0.13168D,  -62.60466D,  -0.16106D,  -62.34109D,   1.09499D],  $  ;  90
 [  -66.43801D,   0.13168D,  -66.71142D,  -1.12373D,  -62.87713D,  -1.41655D,  -62.60466D,  -0.16106D],  $
 [  -66.71142D,  -1.12374D,  -66.97610D,  -2.37967D,  -63.13908D,  -2.67296D,  -62.87713D,  -1.41656D],  $
 [  -66.97610D,  -2.37967D,  -67.25202D,  -3.63458D,  -63.41046D,  -3.92875D,  -63.13908D,  -2.67296D],  $
 [  -67.25202D,  -3.63457D,  -67.51971D,  -4.88994D,  -63.67179D,  -5.18536D,  -63.41046D,  -3.92875D],  $
 [  -67.51971D,  -4.88994D,  -67.79920D,  -6.14416D,  -63.94309D,  -6.44129D,  -63.67179D,  -5.18536D],  $
 [  -67.79920D,  -6.14416D,  -68.07097D,  -7.39879D,  -64.20481D,  -7.69795D,  -63.94309D,  -6.44129D],  $
 [  -68.07097D,  -7.39879D,  -68.34518D,  -8.65298D,  -64.46710D,  -8.95457D,  -64.20481D,  -7.69794D],  $
 [  -68.34518D,  -8.65298D,  -68.63211D,  -9.90586D,  -64.74022D, -10.21040D,  -64.46710D,  -8.95458D],  $
 [  -68.63211D,  -9.90587D,  -68.91209D, -11.15906D,  -65.00445D, -11.46685D,  -64.74022D, -10.21040D],  $
 [  -68.91209D, -11.15906D,  -69.20547D, -12.41081D,  -65.28013D, -12.72242D,  -65.00445D, -11.46685D],  $  ; 100
 [  -69.20547D, -12.41080D,  -69.49247D, -13.66280D,  -65.54739D, -13.97853D,  -65.28013D, -12.72241D],  $
 [  -69.49247D, -13.66279D,  -69.78343D, -14.91412D,  -65.81657D, -15.23442D,  -65.54739D, -13.97852D],  $
 [  -69.78342D, -14.91412D,  -70.06846D, -16.16566D,  -66.07769D, -16.49077D,  -65.81657D, -15.23442D],  $
 [  -70.06846D, -16.16566D,  -70.35803D, -17.41647D,  -66.34118D, -17.74685D,  -66.07769D, -16.49078D],  $
 [  -70.35803D, -17.41648D,  -70.65250D, -18.66651D,  -66.60734D, -19.00260D,  -66.34118D, -17.74685D],  $
 [  -70.65250D, -18.66651D,  -70.95226D, -19.91571D,  -66.87649D, -20.25798D,  -66.60734D, -19.00260D],  $
 [  -70.95226D, -19.91571D,  -71.25769D, -21.16403D,  -67.14894D, -21.51297D,  -66.87649D, -20.25799D],  $
 [  -71.25769D, -21.16402D,  -71.56924D, -22.41139D,  -67.42505D, -22.76751D,  -67.14894D, -21.51296D],  $
 [  -71.56924D, -22.41139D,  -71.88734D, -23.65775D,  -67.70518D, -24.02157D,  -67.42505D, -22.76751D],  $
 [  -71.88734D, -23.65775D,  -72.21249D, -24.90303D,  -67.98972D, -25.27512D,  -67.70518D, -24.02157D],  $  ; 110
 [  -72.21249D, -24.90304D,  -72.54519D, -26.14717D,  -68.27906D, -26.52810D,  -67.98972D, -25.27512D],  $
 [  -72.54519D, -26.14717D,  -72.88600D, -27.39009D,  -68.57366D, -27.78046D,  -68.27906D, -26.52809D],  $
 [  -72.88600D, -27.39009D,  -73.23551D, -28.63171D,  -68.87396D, -29.03217D,  -68.57366D, -27.78046D],  $
 [  -73.23551D, -28.63172D,  -73.59434D, -29.87196D,  -69.18047D, -30.28318D,  -68.87396D, -29.03217D],  $
 [  -73.59434D, -29.87196D,  -73.95175D, -31.11202D,  -69.48220D, -31.53431D,  -69.18047D, -30.28318D],  $
 [  -73.95175D, -31.11203D,  -74.31960D, -32.35062D,  -69.79092D, -32.78467D,  -69.48220D, -31.53431D],  $
 [  -74.31959D, -32.35061D,  -74.68692D, -33.58898D,  -70.09539D, -34.03514D,  -69.79092D, -32.78468D],  $
 [  -74.68692D, -33.58899D,  -75.07784D, -34.82436D,  -70.41977D, -35.28382D,  -70.09539D, -34.03514D],  $
 [  -75.07784D, -34.82436D,  -75.46961D, -36.05941D,  -70.74084D, -36.53255D,  -70.41977D, -35.28382D],  $
 [  -75.46961D, -36.05941D,  -75.88716D, -37.29114D,  -71.08359D, -37.77933D,  -70.74084D, -36.53255D],  $  ; 120
 [  -75.88716D, -37.29114D,  -76.30721D, -38.52240D,  -71.42420D, -39.02606D,  -71.08359D, -37.77933D],  $
 [  -76.30721D, -38.52240D,  -76.73027D, -39.75321D,  -71.76287D, -40.27278D,  -71.42420D, -39.02606D],  $
 [  -76.73027D, -39.75321D,  -77.16981D, -40.98190D,  -72.11293D, -41.51840D,  -71.76287D, -40.27277D],  $
 [  -77.16981D, -40.98191D,  -77.62713D, -42.20836D,  -72.47536D, -42.76286D,  -72.11293D, -41.51840D],  $
 [  -77.62713D, -42.20836D,  -78.09031D, -43.43419D,  -72.83765D, -44.00723D,  -72.47537D, -42.76286D],  $
 [  -78.09031D, -43.43419D,  -78.58739D, -44.65571D,  -73.22794D, -45.24913D,  -72.83765D, -44.00722D],  $
 [  -78.58739D, -44.65571D,  -79.10700D, -45.87445D,  -73.63423D, -46.48960D,  -73.22794D, -45.24913D],  $
 [  -79.10700D, -45.87445D,  -79.63688D, -47.09217D,  -74.04346D, -47.72980D,  -73.63423D, -46.48960D],  $
 [  -79.63688D, -47.09217D,  -80.19276D, -48.30680D,  -74.47114D, -48.96844D,  -74.04346D, -47.72981D],  $
 [  -80.19276D, -48.30679D,  -80.76212D, -49.52020D,  -74.90380D, -50.20675D,  -74.47114D, -48.96844D],  $  ; 130
 [  -80.76212D, -49.52020D,  -81.34652D, -50.73235D,  -75.34228D, -51.44476D,  -74.90380D, -50.20675D],  $
 [  -81.34652D, -50.73235D,  -81.97877D, -51.93859D,  -75.81961D, -52.67950D,  -75.34228D, -51.44476D],  $
 [  -81.97877D, -51.93859D,  -82.64723D, -53.14070D,  -76.32301D, -53.91219D,  -75.81961D, -52.67950D],  $
 [  -82.64723D, -53.14070D,  -83.33912D, -54.34081D,  -76.83828D, -55.14425D,  -76.32301D, -53.91219D],  $
 [  -83.33912D, -54.34080D,  -84.05715D, -55.53876D,  -77.36704D, -56.37565D,  -76.83828D, -55.14424D],  $
 [  -84.05715D, -55.53876D,  -84.83893D, -56.72900D,  -77.94735D, -57.60290D,  -77.36704D, -56.37565D],  $
 [  -84.83893D, -56.72900D,  -85.65540D, -57.91629D,  -78.54757D, -58.82914D,  -77.94735D, -57.60290D],  $
 [  -85.65540D, -57.91629D,  -86.51079D, -59.10041D,  -79.17045D, -60.05434D,  -78.54757D, -58.82915D],  $
 [  -86.51079D, -59.10041D,  -87.42876D, -60.27793D,  -79.83925D, -61.27640D,  -79.17045D, -60.05434D],  $
 [  -87.42876D, -60.27793D,  -88.41669D, -61.44810D,  -80.56002D, -62.49494D,  -79.83925D, -61.27640D],  $  ; 140
 [  -88.41669D, -61.44810D,  -89.48305D, -62.60997D,  -81.33987D, -63.70952D,  -80.56002D, -62.49494D],  $
 [  -89.48305D, -62.60997D,  -90.63764D, -63.76251D,  -82.18722D, -64.91957D,  -81.33986D, -63.70951D],  $
 [  -90.63764D, -63.76251D,  -91.87033D, -64.90821D,  -83.08855D, -66.12694D,  -82.18722D, -64.91957D],  $
 [  -91.87033D, -64.90821D,  -93.19203D, -66.04619D,  -84.05264D, -67.33125D,  -83.08855D, -66.12694D],  $
 [  -93.19204D, -66.04619D,  -94.66162D, -67.16704D,  -85.14182D, -68.52654D,  -84.05263D, -67.33125D],  $
 [  -94.66162D, -67.16704D,  -96.25156D, -68.27689D,  -86.32274D, -69.71710D,  -85.14182D, -68.52654D],  $
 [  -96.25156D, -68.27689D,  -97.98010D, -69.37408D,  -87.61240D, -70.90213D,  -86.32274D, -69.71711D],  $
 [  -97.98010D, -69.37408D,  -99.86885D, -70.45656D,  -89.03201D, -72.08059D,  -87.61240D, -70.90213D],  $
 [  -99.86885D, -70.45656D, -101.99612D, -71.51136D,  -90.67202D, -73.24400D,  -89.03201D, -72.08059D],  $
 [ -101.99612D, -71.51136D, -104.37011D, -72.53899D,  -92.54417D, -74.39287D,  -90.67202D, -73.24400D],  $  ; 150
 [ -104.37011D, -72.53899D, -107.02867D, -73.53442D,  -94.69975D, -75.52377D,  -92.54417D, -74.39287D],  $
 [ -107.02867D, -73.53442D, -109.95823D, -74.50411D,  -97.12888D, -76.64127D,  -94.69975D, -75.52377D],  $
 [ -109.95823D, -74.50411D, -113.26177D, -75.42957D,  -99.98275D, -77.73192D,  -97.12888D, -76.64127D],  $
 [ -113.26177D, -75.42957D, -116.99193D, -76.30189D, -103.36998D, -78.78791D,  -99.98275D, -77.73192D],  $
 [ -116.99193D, -76.30188D, -121.17395D, -77.11792D, -107.38593D, -79.80450D, -103.36998D, -78.78791D],  $
 [ -121.17395D, -77.11792D, -125.88592D, -77.85827D, -112.24699D, -80.76213D, -107.38593D, -79.80450D],  $
 [ -125.88592D, -77.85827D, -131.13846D, -78.51690D, -118.11827D, -81.64784D, -112.24699D, -80.76213D],  $
 [ -131.13846D, -78.51690D, -136.98977D, -79.06102D, -125.31518D, -82.42028D, -118.11827D, -81.64784D],  $
 [ -136.98977D, -79.06102D, -143.35902D, -79.49164D, -133.92408D, -83.05921D, -125.31518D, -82.42028D],  $
 [ -143.35902D, -79.49164D, -150.16747D, -79.79441D, -143.98925D, -83.51561D, -133.92408D, -83.05921D],  $  ; 160
 [ -150.16747D, -79.79441D, -157.28399D, -79.94795D, -155.16269D, -83.75916D, -143.98925D, -83.51561D],  $
 [ -157.28399D, -79.94795D, -164.50711D, -79.94542D, -166.76772D, -83.75510D, -155.16269D, -83.75916D],  $
 [ -164.50711D, -79.94542D, -171.61665D, -79.78693D, -177.91355D, -83.50388D, -166.76772D, -83.75510D],  $
 [ -171.61665D, -79.78693D, -178.41231D, -79.47953D, -187.89788D, -83.03217D, -177.91355D, -83.50388D],  $
 [ -178.41231D, -79.47953D, -184.74421D, -79.03572D, -196.40907D, -82.38081D, -187.89788D, -83.03217D],  $
 [ -184.74421D, -79.03572D, -190.52524D, -78.47124D, -203.46581D, -81.59139D, -196.40907D, -82.38081D],  $
 [ -190.52524D, -78.47124D, -195.72582D, -77.80279D, -209.29956D, -80.70559D, -203.46581D, -81.59139D],  $
 [ -195.72582D, -77.80279D, -200.38686D, -77.05409D, -214.09157D, -79.74234D, -209.29956D, -80.70559D],  $
 [ -200.38686D, -77.05409D, -204.54954D, -76.23818D, -218.09332D, -78.72687D, -214.09157D, -79.74234D],  $
 [ -204.54954D, -76.23818D, -208.23624D, -75.35953D, -221.43265D, -77.66707D, -218.09332D, -78.72687D],  $  ; 170
 [ -208.23624D, -75.35953D, -211.52869D, -74.43504D, -224.28478D, -76.57796D, -221.43265D, -77.66707D],  $
 [ -211.52869D, -74.43504D, -214.45036D, -73.46639D, -226.71478D, -75.46186D, -224.28478D, -76.57796D],  $
 [ -214.45037D, -73.46639D, -217.04937D, -72.46088D, -228.80550D, -74.32450D, -226.71477D, -75.46186D],  $
 [ -217.04937D, -72.46088D, -219.42109D, -71.43498D, -230.68442D, -73.17739D, -228.80550D, -74.32450D],  $
 [ -219.42109D, -71.43498D, -221.52230D, -70.37687D, -232.30150D, -72.01218D, -230.68442D, -73.17739D],  $
 [ -221.52229D, -70.37688D, -223.41241D, -69.29621D, -233.72980D, -70.83532D, -232.30150D, -72.01217D],  $
 [ -223.41241D, -69.29621D, -225.14295D, -68.20074D, -235.02770D, -69.65175D, -233.72980D, -70.83532D],  $
 [ -225.14295D, -68.20074D, -226.66673D, -67.07989D, -236.13922D, -68.45414D, -235.02770D, -69.65175D],  $
 [ -226.66673D, -67.07989D, -228.05297D, -65.94524D, -237.14103D, -67.24996D, -236.13922D, -68.45414D],  $
 [ -228.05297D, -65.94524D, -229.25497D, -64.78714D, -237.97889D, -66.03258D, -237.14103D, -67.24996D]]     ; 180

;------------------------------------------------------------------------------
; Add the offset to the 4 corner longitude coordinates in each block.
;------------------------------------------------------------------------------

LatLonCoords = LLSwathCoords[*, BlkBeg-1 : BlkEnd-1]

FOR ipt=0,7,2 DO BEGIN
   LatLonCoords[ipt, *] += !KON.Instr.DEG_OFFSET * (Path - 1)
ENDFOR

ndxs = WHERE(LatLonCoords LT WrapLon, numndxs)
IF (numndxs) THEN BEGIN
   LatLonCoords[ndxs] += 360.
ENDIF

ndxs = 0

END  ;  GetSwathLatLonCoords

;***************************************************************************
FUNCTION GetWordMonth, month_int
;***************************************************************************
; Read in the number of the month and converting it into a string.
; --------------------------------------------------------------------------

COMPILE_OPT IDL2, LOGICAL_PREDICATE

  IF (month_int EQ '01') THEN month_word = 'Jan'
  IF (month_int EQ '02') THEN month_word = 'Feb'
  IF (month_int EQ '03') THEN month_word = 'Mar'
  IF (month_int EQ '04') THEN month_word = 'Apr'
  IF (month_int EQ '05') THEN month_word = 'May'
  IF (month_int EQ '06') THEN month_word = 'Jun'
  IF (month_int EQ '07') THEN month_word = 'Jul'
  IF (month_int EQ '08') THEN month_word = 'Aug'
  IF (month_int EQ '09') THEN month_word = 'Sep'
  IF (month_int EQ '10') THEN month_word = 'Oct'
  IF (month_int EQ '11') THEN month_word = 'Nov'
  IF (month_int EQ '12') THEN month_word = 'Dec'

  RETURN, month_word

END  ;  latlon_time_query_month

;***************************************************************************
FUNCTION GetIntMonth, month_word
;***************************************************************************
; Read in the number of the month and converting it into a string.
; --------------------------------------------------------------------------

COMPILE_OPT IDL2, LOGICAL_PREDICATE

  IF (month_word EQ 'Jan') THEN month_int = '01'
  IF (month_word EQ 'Feb') THEN month_int = '02'
  IF (month_word EQ 'Mar') THEN month_int = '03'
  IF (month_word EQ 'Apr') THEN month_int = '04'
  IF (month_word EQ 'May') THEN month_int = '05'
  IF (month_word EQ 'Jun') THEN month_int = '06'
  IF (month_word EQ 'Jul') THEN month_int = '07'
  IF (month_word EQ 'Aug') THEN month_int = '08'
  IF (month_word EQ 'Sep') THEN month_int = '09'
  IF (month_word EQ 'Oct') THEN month_int = '10'
  IF (month_word EQ 'Nov') THEN month_int = '11'
  IF (month_word EQ 'Dec') THEN month_int = '12'

  RETURN, month_int

END  ;  latlon_time_query_month

;**************************************************************************
PRO LineLineIntersect, Line1, Line2, Result
;**************************************************************************
; Find where two lines intersect.
; Line dims: [2,2] where dim1 is 0=x, 1=y and dim2 is 0=point1, 1=point2
; a, b, c             =>  Coefficients of line equations
; r                   =>  'Sign' values
; denom, offset, num  =>  Intermediate values
; Result flag values: 0 => no intersection; 1 = intersection; 2 = collinear.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Compute a1, b1, c1, where the line joining points 1 and 2 is:
; a1 x  +  b1 y  +  c1  =  0.
;--------------------------------------------------------------------------

a1 = Line1[1,1] - Line1[1,0]
b1 = Line1[0,0] - Line1[0,1]
c1 = Line1[0,1] * Line1[1,0] - Line1[0,0] * Line1[1,1]

;--------------------------------------------------------------------------
; Compute r3 and r4.
;--------------------------------------------------------------------------

r3 = a1 * Line2[0,0] + b1 * Line2[1,0] + c1
r4 = a1 * Line2[0,1] + b1 * Line2[1,1] + c1

;--------------------------------------------------------------------------
; Check signs of r3 and r4.  If both point 3 and point 4 lie on same side
; of line 1, the line segments do not intersect.
;--------------------------------------------------------------------------

same_sign = (r3 GE 0.0 AND r4 GE 0.0) OR (r3 LT 0.0 AND r4 LT 0.0)

IF ( r3 NE 0 AND r4 NE 0 AND same_sign ) THEN BEGIN
   Result = 0
   RETURN
ENDIF

;--------------------------------------------------------------------------
; Compute a2, b2, c2.
;--------------------------------------------------------------------------

a2 = Line2[1,1] - Line2[1,0]
b2 = Line2[0,0] - Line2[0,1]
c2 = Line2[0,1] * Line2[1,0] - Line2[0,0] * Line2[1,1]

;--------------------------------------------------------------------------
; Compute r1 and r2.
;--------------------------------------------------------------------------

r1 = a2 * Line1[0,0] + b2 * Line1[1,0] + c2
r2 = a2 * Line1[0,1] + b2 * Line1[1,1] + c2

;--------------------------------------------------------------------------
; Check signs of r1 and r2.  If both point 1 and point 2 lie on same side
; of second line segment, the line segments do not intersect.
;--------------------------------------------------------------------------

same_sign = (r1 GE 0.0 AND r2 GE 0.0) OR (r1 LT 0.0 AND r2 LT 0.0)

IF ( r1 NE 0 AND r2 NE 0 AND same_sign ) THEN BEGIN
   Result = 0
   RETURN
ENDIF

;--------------------------------------------------------------------------
; Line segments intersect: compute intersection point. 
;--------------------------------------------------------------------------

denom = a1 * b2 - a2 * b1
IF ( denom EQ 0.0 ) THEN BEGIN
   Result = 2
   RETURN
ENDIF

;--------------------------------------------------------------------------
; Compute the intersection.
;--------------------------------------------------------------------------

;IntPt[0] = (b1 * c2 - b2 * c1) / denom
;IntPt[1] = (a2 * c1 - a1 * c2) / denom

Result = 1
RETURN

END  ;  LineLineIntersect

;**************************************************************************
FUNCTION RectRectIntersect, R1_lats, R1_lons, R2_lats, R2_lons
;**************************************************************************
; Test whether two rectangles intersect.
; Result flag values: 0 => no intersection; 1 = intersection.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Loop over the edges of the first rectangle, then the second. Test whether
; any edges intersect.
;--------------------------------------------------------------------------

FOR iedge1=0,3 DO BEGIN
   Edge1 = [[R1_lats[iedge1],   R1_lons[iedge1]], $
            [R1_lats[iedge1+1], R1_lons[iedge1+1]]]

   FOR iedge2=0,3 DO BEGIN
      Edge2 = [[R2_lats[iedge2],   R2_lons[iedge2]], $
               [R2_lats[iedge2+1], R2_lons[iedge2+1]]]

      LineLineIntersect, Edge1, Edge2, Result
      IF (Result) then RETURN, Result
   ENDFOR
ENDFOR

RETURN, 0

END  ;  RectRectIntersect

;**************************************************************************
FUNCTION PointInPolygon, nPts, RectLat, RectLon, PtLat, PtLon
;**************************************************************************
; Find whether a point lies within a polygon. Return 1 if the point is
; inside the polygon and 0 if it is outside the polygon.
;--------------------------------------------------------------------------

ii = INDGEN(nPts)               ; Counter (0:nPts-1)
ip = INDGEN(nPts) + 1           ; Counter (1:nx)
 
X1 = RectLon(ii) - PtLon
Y1 = RectLat(ii) - PtLat
X2 = RectLon(ip) - PtLon
Y2 = RectLat(ip) - PtLat

dp = X1 * X2 + Y1 * Y2          ; Dot-product
cp = X1 * Y2 - Y1 * X2          ; Cross-product

theta = ATAN(cp, dp)

IF (ABS(TOTAL(theta)) GT !PI) THEN RETURN, 1 ELSE RETURN, 0

END  ;  PointInPolygon

;**************************************************************************
PRO RectSwathIntersect, Nblks, SW_Lat, SW_Lon, RE_Lat, RE_Lon, BlkBeg, BlkEnd
;**************************************************************************
; Find the points of intersection between block rectangles describing the
; MISR SWath and a REctangle describing the region of interest for finding
; orbits. Rectangle points are ordered: bottom lat, top lat, left lon,
; right lon. Result flag values: 0 => no intersection; 1 = intersection.
;--------------------------------------------------------------------------

bFirst =  0
BlkBeg = -1
BlkEnd = -1

;--------------------------------------------------------------------------
; Determine whether any blocks within the block range are intersected by
; the search rectangle. If so, return the first and last blocks intersected.
;--------------------------------------------------------------------------

FOR iblk=0,Nblks-1 DO BEGIN

   BlkISect = RectRectIntersect(SW_Lat[iblk,*], SW_Lon[iblk,*], RE_Lat, RE_Lon)

   ;-----------------------------------------------------------------------
   ; If no intersection was found, test for the case where the 2nd rectangle
   ; lies completely within the 1st. This requires testing only one point
   ; of the 2nd rectangle.
   ;-----------------------------------------------------------------------

   IF (~BlkISect) THEN BEGIN
      BlkISect = PointInPolygon(5, SW_Lat[iblk,*], SW_Lon[iblk,*], $
                                RE_Lat[0], RE_Lon[0])
   ENDIF

   ;-----------------------------------------------------------------------
   ; Save the first and last blocks where there were intersections.
   ;-----------------------------------------------------------------------

   IF (BlkISect) THEN BEGIN
      IF (~bFirst) THEN BEGIN
         BlkBeg = iblk
         bFirst = 1
      ENDIF
      BlkEnd = iblk
   ENDIF
ENDFOR

END  ;  RectSwathIntersect

;**************************************************************************
PRO GetBlockRangeFromLatitudes, Lats, BlkMin, BlkMax
;**************************************************************************
; Find the smallest and largest block numbers needed for this search based
; on the latitude range. Any latitude above 64 deg requires blocks 1-39,
; and any latitude below -64 requires blocks 142-180. In these high
; latitude ranges, the paths double back on themselves over the pole.
;--------------------------------------------------------------------------

BlkMin = !KON.Instr.NUM_BLOCKS
BlkMax = 1

;--------------------------------------------------------------------------
; If maximum latitude is above 64, set the minimum block to 1. The maximum
; block must be >= 39.
;--------------------------------------------------------------------------

IF (Lats[1] GT 64.0) THEN BEGIN
   BlkMin = 1
   BlkMax = 39
ENDIF

;--------------------------------------------------------------------------
; If minimum latitude is below -64, set the maximum block to 180. The minimum
; block must be <= 142.
;--------------------------------------------------------------------------

IF (Lats[0] LT -64.0) THEN BEGIN
   BlkMax = !KON.Instr.NUM_BLOCKS
   BlkMin = 142
ENDIF

;--------------------------------------------------------------------------
; Retrieve AGP block corner lat/lon coords for all the blocks of path 1.
; Point order is upper left, lower left, lower right, upper right.
;--------------------------------------------------------------------------

lat = FLTARR(!KON.Instr.NUM_BLOCKS+1, 4)
lon = FLTARR(!KON.Instr.NUM_BLOCKS+1, 4)

GetPathLatLonCoords, 1, 1, 180, -720.0, LatLonCoords

FOR iblk=0,!KON.Instr.NUM_BLOCKS-1 DO BEGIN
   FOR ipt1=0,3 DO BEGIN
      ipt2 = ipt1 * 2
      lon[iblk,ipt1] = LatLonCoords[ipt2,iblk]
      lat[iblk,ipt1] = LatLonCoords[ipt2+1,iblk]
   ENDFOR
ENDFOR

LatLonCoords = 0

;--------------------------------------------------------------------------
; Determine the smallest block number needed for this search. Use the lower
; corner latitudes.
;--------------------------------------------------------------------------

FOR iblk=0,!KON.Instr.NUM_BLOCKS-1 DO BEGIN
   IF (lat[iblk,2] LT Lats[1] OR lat[iblk,3] LT Lats[1]) THEN BEGIN
      BlkMin = BlkMin < iblk + 1
      BREAK
   ENDIF
ENDFOR

;--------------------------------------------------------------------------
; Determine the largest block number needed for this search. Use the upper
; corner latitudes. 
;--------------------------------------------------------------------------

FOR iblk=!KON.Instr.NUM_BLOCKS-1,0,-1 DO BEGIN
   IF (lat[iblk,0] GT Lats[0] OR lat[iblk,1] GT Lats[0]) THEN BEGIN
      BlkMax = BlkMax > iblk + 1
      BREAK
   ENDIF
ENDFOR

lat = 0

END  ;  GetBlockRangeFromLatitudes

;***************************************************************************
PRO GetPathsForRegionOrPt, IsRegion, Lats, Lons, DEBUG_ON, nPath, Paths, $
                           BlkBegs, BlkEnds
;***************************************************************************
; For a given region specified as lat-lon min-max coordinates, find all the
; MISR paths that intersect that region. Return a pathlist as well as a list
; for each path of the 4 coordinate pairs where the region intersects the
; blocks of the path.
;---------------------------------------------------------------------------

COMPILE_OPT idl2, LOGICAL_PREDICATE, STRICTARRSUBS

Paths   = INTARR(!KON.Instr.NUM_PATHS)
BlkBegs = INTARR(!KON.Instr.NUM_PATHS)
BlkEnds = INTARR(!KON.Instr.NUM_PATHS)
nPath   =  0
Status  = -1

;----------------------------------------------------------------------------
; Test input parameters.
;----------------------------------------------------------------------------

IF (IsRegion) THEN BEGIN
   IF (Lats[1] LT Lats[0]) THEN BEGIN
      mssg = 'The end latitude is smaller than the begin latitude.'
      rtrn = DIALOG_MESSAGE(mssg, /CENTER, /ERROR)
      RETURN
   ENDIF
   IF (Lons[1] LT Lons[0]) THEN BEGIN
      IF (Lons[0] LT 170. OR Lons[1] GT -170.) THEN BEGIN
         mssg = ['The end longitude is smaller than the begin longitude.', $
                 'If you wish to cross the dateline, the begin and end', $
                 'longitudes must be within +170 and -170 degrees.']
         rtrn = DIALOG_MESSAGE(mssg, /CENTER, /ERROR)
         RETURN
      ENDIF ELSE BEGIN
         Lons[0] -= 360.0
      ENDELSE
   ENDIF
ENDIF

;----------------------------------------------------------------------------
; Limit the search to a particular range of blocks based on the min and max
; latitudes specified by user.
;----------------------------------------------------------------------------

GetBlockRangeFromLatitudes, Lats, BlkMin, BlkMax

BlkMin = BlkMin > 1
BlkMax = BlkMax < 180

;----------------------------------------------------------------------------
; Construct search rectangle lat/lon coords. Also create a duplicate region
; but 360 deg west. This is needed, since successive paths are progressively
; west of previous ones.
;----------------------------------------------------------------------------

RE_lats = [Lats[1], Lats[0], Lats[0], Lats[1], Lats[1]]
RE_lons = [Lons[0], Lons[0], Lons[1], Lons[1], Lons[0]]
RE_lons1 = RE_lons - 360.0

;----------------------------------------------------------------------------
; Loop over all the MISR paths.
;----------------------------------------------------------------------------

PathMin = 1
PathMax = 233

FOR ipath=PathMin,PathMax DO BEGIN

   ;-------------------------------------------------------------------------
   ; Construct AGP block corner lat/lon data for the selected blocks on this
   ; path. Point order is upper left, lower left, lower right, upper right.
   ;-------------------------------------------------------------------------

   lat_swath = FLTARR(BlkMax-BlkMin+1, 5)
   lon_swath = FLTARR(BlkMax-BlkMin+1, 5)

   GetSwathLatLonCoords, ipath, BlkMin, BlkMax, -720.0, LatLonCoords

   FOR ipt1=0,3 DO BEGIN
      ipt2 = ipt1 * 2
      lon_swath[*,ipt1] = LatLonCoords[ipt2,*]
      lat_swath[*,ipt1] = LatLonCoords[ipt2+1,*]
   ENDFOR
   
   lon_swath[*,4] = LatLonCoords[0,*]
   lat_swath[*,4] = LatLonCoords[1,*]

   LatLonCoords = 0

   ;--------------------------------------------------------------------------
   ; Find the intersection points between the blocks of the swath for this
   ; path and the 2 geographic search rectangles (2nd rectangle is the western
   ; duplicate mentioned above).
   ;--------------------------------------------------------------------------

   RectSwathIntersect, BlkMax-BlkMin+1, lat_swath, lon_swath, RE_lats, $
                       RE_lons, BlkBeg, BlkEnd

   RectSwathIntersect, BlkMax-BlkMin+1, lat_swath, lon_swath, RE_lats, $
                       RE_lons1, BlkBeg1, BlkEnd1

   ;--------------------------------------------------------------------------
   ; Record where first and last block intersections were found.
   ;--------------------------------------------------------------------------

   IF (BlkBeg GE 0 OR BlkBeg1 GE 0) THEN BEGIN
      IF (BlkBeg GE 0) THEN BEGIN
         BlkBegs[nPath] = BlkBeg + BlkMin
         BlkEnds[nPath] = BlkEnd + BlkMin
         lon_vals = RE_lons
      ENDIF

      IF (BlkBeg1 GE 0) THEN BEGIN
         BlkBegs[nPath] = BlkBeg1 + BlkMin
         BlkEnds[nPath] = BlkEnd1 + BlkMin
         lon_vals = RE_lons1
      ENDIF

      Paths[nPath] = ipath
      nPath += 1

      ;-----------------------------------------------------------------------
      ; For debugging, display the swath blocks and the 2 search rectangles
      ; for each successful path.
      ;-----------------------------------------------------------------------

      IF (DEBUG_ON) THEN BEGIN
         lat_blks = FLTARR(180, 5)
         lon_blks = FLTARR(180, 5)

         GetSwathLatLonCoords, ipath, 1, 180, -720.0, llCoords

         FOR ipt1=0,3 DO BEGIN
            ipt2 = ipt1 * 2
            lon_blks[*,ipt1] = llCoords[ipt2,*]
            lat_blks[*,ipt1] = llCoords[ipt2+1,*]
         ENDFOR
         lon_blks[*,4] = llCoords[0,*]
         lat_blks[*,4] = llCoords[1,*]

         llCoords = 0

         WINDOW, 3, XPOS=1000, YPOS=500, XSIZE=1200, YSIZE=800

         PLOT, [0.0,0.0001],[0.0,0.0], TITLE='Path ' + STRTRIM(STRING(ipath),2), $
               XRANGE=[-540,180], XSTYLE=1, XGRIDSTYLE=1, XTICKLEN=1, XTICKS=36, $
               YRANGE=[-90,90],   YSTYLE=1, YGRIDSTYLE=1, YTICKLEN=1, YTICKS=40, $
               COLOR=0, BACKGROUND=16777215
               
         FOR iblk=0,179 DO BEGIN
            OPLOT, lon_blks[iblk,*], lat_blks[iblk,*], COLOR='0000FF'XUL
         ENDFOR

         OPLOT, lon_vals, RE_lats, COLOR='FF0000'XUL

         WAIT, 0.5

         lat_blks = 0
         lon_blks = 0
      ENDIF

   ENDIF
ENDFOR

;----------------------------------------------------------------------------
; Clean up data to return.
;----------------------------------------------------------------------------

IF (nPath GT 0) THEN BEGIN
   Paths   = Paths[0:nPath-1]
   BlkBegs = BlkBegs[0:nPath-1]
   BlkEnds = BlkEnds[0:nPath-1]
ENDIF

;----------------------------------------------------------------------------
; Clean up.
;----------------------------------------------------------------------------

RE_lats  = 0
RE_lons  = 0
RE_lons1 = 0

lat_swath = 0
lon_swath = 0
lon_vals  = 0

Status = 0

END  ;  GetPathsForRegionOrPt

;***************************************************************************
PRO OverpassFinder, ForOrder, OrbitList, Status
;***************************************************************************
; Find orbits and block ranges where a specified square, geographic search
; rectangle intersects orbits within a specified time window.
;---------------------------------------------------------------------------

COMPILE_OPT idl2, LOGICAL_PREDICATE, STRICTARRSUBS

Status = -1

;---------------------------------------------------------------------------
; Initialization.
;---------------------------------------------------------------------------

DEBUG_ON = 0   ;    set to 0 for production;
               ;            debugging displays if set to 1

USER_SELECT_PNG = 0  ; if 0, automatically save .png images
                     ; if 1, let user answer questions about saving

date_fmt = '(C(CYI4.4,"-",CMOI2.2,"-",CDI2.2))'
time_fmt = '(C(CHI2.2,":",CMI2.2, ":",CSI2.2))'

latval = FLTARR(4)
lonval = FLTARR(4)

;wndw_work = 30

;---------------------------------------------------------------------------
; Display the dialog box. 
;---------------------------------------------------------------------------

nextpass:

total_orbits = 0

IF (~ForOrder) THEN BEGIN
   OverpassTimeLocGui, LL_list, TM_list, GMToffset, retval
   IF (retval LT 0) THEN RETURN
ENDIF ELSE BEGIN
   retval = -1
   IF (retval LT 0) THEN RETURN
ENDELSE

NumObj = N_ELEMENTS(LL_list) / 4

;---------------------------------------------------------------------------
; Get the last used or default name for the output overpass directory.
; Create a new directory if needed.
;---------------------------------------------------------------------------

IF (~ForOrder) THEN BEGIN
   file_filter = ['*']

   GetLastFilename, 0, !KON.FileTyp.TypeOverpassDir, file_filter, 0, $
                    file_outpath, temp_Overpass_dir

   !VAR.CurrFiles.OverpassFile = temp_Overpass_dir
   IF (!VAR.CurrFiles.OverpassFile EQ '') THEN BEGIN
      Status = -2
      GOTO, nextpass
   ENDIF

   IF (~ FILE_TEST(temp_Overpass_dir, /DIRECTORY)) THEN BEGIN
      rtrn_val = MakeDirectory(temp_Overpass_dir)
      rtrn_val = ChmodCatchError(temp_Overpass_dir, '777'O)
   ENDIF
ENDIF ELSE BEGIN


ENDELSE

;---------------------------------------------------------------------------
; Create a window to show 'Waiting...' during retrieval.
;---------------------------------------------------------------------------

;old_font = GetFontInfo(0)
;SetFontInfo, {Type:!KON.FontTyp.FONT_DEVICE, Size:'14', Face:'bold'}
;char_spac = (!P.FONT EQ !KON.FontTyp.FONT_DEVICE) ? 1.0 : 1.5
;
;pwin = !D.WINDOW
;SafeWDELETE, pwin, didit
;
;WINDOW, wndw_work, XPOS=900, YPOS=600, XSIZE=350, YSIZE=80,TITLE=' '
;PLOT, [0,0], [0,1], BACKGROUND=16777215, COLOR=16777215, XSTYLE=4, YSTYLE=4
;mssg = 'Searching for overpass orbits......'
;XYOUTS, 25,48, mssg, /DEVICE, COLOR=0, CHARSIZE=2
;
;SetFontInfo, old_font

;---------------------------------------------------------------------------
; Generate the system time to add into the filename, open (create) the
; output txt file in the user's home directory and write in the headers.
;---------------------------------------------------------------------------

IF (~ForOrder) THEN BEGIN
   datetime = SYSTIME()
   tok1 = STRSPLIT(datetime, ' ', /EXTRACT, COUNT=ntok1s)
   tok2 = STRSPLIT(tok1[3],  ':', /EXTRACT, COUNT=ntok2s)
   time = tok2[0] + '.' + tok2[1] + '.' + tok2[2]
   date = tok1[1] + tok1[2] + '-' + tok1[4] + '-' + time

   ReportFile = !VAR.CurrFiles.OverpassFile + !KON.Misc.Slash + $
                'MISR_OverpassLog_' + date + '.txt'

   OPENW, rpt_unit, ReportFile, /GET_LUN
ENDIF

;------------------------------------------------------------------------
; Create an array of structures to hold orbit information.
;------------------------------------------------------------------------

DataStruct = { orbit        : 0L, $
               path         : 0,  $
               beg_blk      : 0,  $
               beg_date_gmt : '', $
               beg_time_gmt : '', $
               beg_date_loc : '', $
               beg_time_loc : '', $
               end_blk      : 0,  $
               end_date_gmt : '', $
               end_time_gmt : '', $
               end_date_loc : '', $
               end_time_loc : '' }

;---------------------------------------------------------------------------
; Loop over the objects.
;---------------------------------------------------------------------------

FOR iobj = 0, NumObj-1 DO BEGIN

   norbit = 0L
   DataList = [DataStruct]

   ;------------------------------------------------------------------------
   ; Use region lats and lons to produce a pathlist and number of paths that
   ; match this location.  This pathlist is what we'll loop through and
   ; check to see if a MISR overpass happens for each path generated given
   ; the input start and end times.
   ;------------------------------------------------------------------------

   is_region = (LL_list[0,iobj] NE LL_list[1,iobj]) OR $
               (LL_list[2,iobj] NE LL_list[3,iobj])

   numpts = is_region ? 4 : 1

   GetPathsForRegionOrPt, is_region, LL_list[0:1, iobj], LL_list[2:3, iobj], $
                          DEBUG_ON, npath, pathlist, blk_begs, blk_ends

   IF (npath LT 1) THEN CONTINUE

   ;------------------------------------------------------------------------
   ; Convert the user's start and end times, which are in LOCAL time, to
   ; julian time for arithmetic manipulation. Then convert both to GMT time.
   ;------------------------------------------------------------------------

   beg_date = TM_list[0,iobj]
   beg_time = TM_list[1,iobj]
   date_elems = STRSPLIT(beg_date, '-', /EXTRACT)
   time_elems = STRSPLIT(beg_time, ':', /EXTRACT)
   beg_jul_loc = JULDAY(FIX(date_elems[1]), FIX(date_elems[2]), FIX(date_elems[0]), $
                        FIX(time_elems[0]), FIX(time_elems[1]), FIX(time_elems[2]))
   beg_jul_gmt = beg_jul_loc - GMToffset / 24.0D  ; convert to julian GMT time

   end_date = TM_list[2,iobj]
   end_time = TM_list[3,iobj]
   date_elems = STRSPLIT(end_date, '-', /EXTRACT)
   time_elems = STRSPLIT(end_time, ':', /EXTRACT)
   end_jul_loc = JULDAY(FIX(date_elems[1]), FIX(date_elems[2]), FIX(date_elems[0]), $
                        FIX(time_elems[0]), FIX(time_elems[1]), FIX(time_elems[2]))
   end_jul_gmt = end_jul_loc - GMToffset / 24.0D  ; convert to julian GMT time

   ;------------------------------------------------------------------------
   ; Find the first and last orbit numbers that bracket the date range.
   ;------------------------------------------------------------------------

   Orbit1 = -1L
   Block1 = -1
   Get_OrbitTime_OrbitNumber, beg_jul_gmt, 1, Orbit1, Block1, status1

   Orbit2 = -1L
   Block2 = -1
   Get_OrbitTime_OrbitNumber, end_jul_gmt, 1, Orbit2, Block2, status2

   ;------------------------------------------------------------------------
   ; Loop over the paths that intersect the search region.
   ;------------------------------------------------------------------------

   FOR ipath=0,npath-1 DO BEGIN

      ;---------------------------------------------------------------------
      ; this_path defines the path we are looking for orbits in. 
      ;---------------------------------------------------------------------

      this_path = pathlist[ipath]

      ;---------------------------------------------------------------------
      ; Loop over all orbits in the specified time range.
      ;---------------------------------------------------------------------

      FOR iOrbit=Orbit1,Orbit2 DO BEGIN

         this_orbit_path = PathFromOrbit(iOrbit)

         ;------------------------------------------------------------------
         ; Keep only those orbits in time range that are on a qualifying path.
         ;------------------------------------------------------------------

         IF (this_orbit_path EQ this_path) THEN BEGIN

            ;---------------------------------------------------------------
            ; Convert the orbit number and first and last blocks to julian
            ; time. Then convert both to local time also.
            ;---------------------------------------------------------------

            julian1_gmt = -1.0
            Get_OrbitTime_OrbitNumber, julian1_gmt, 1, iOrbit, blk_begs[ipath], $
                                       retval
            julian1_loc = julian1_gmt + GMToffset / 24. ; convert to julian local

            julian2_gmt = -1.0
            Get_OrbitTime_OrbitNumber, julian2_gmt, 1, iOrbit, blk_ends[ipath], $
                                       retval
            julian2_loc = julian2_gmt + GMToffset / 24. ; convert to julian local

            DataStruct.orbit        = iOrbit
            DataStruct.path         = this_path
            DataStruct.beg_blk      = blk_begs[ipath]
            DataStruct.beg_date_gmt = STRING(FORMAT=date_fmt, julian1_gmt)
            DataStruct.beg_time_gmt = STRING(FORMAT=time_fmt, julian1_gmt)
            DataStruct.beg_date_loc = STRING(FORMAT=date_fmt, julian1_loc)
            DataStruct.beg_time_loc = STRING(FORMAT=time_fmt, julian1_loc)
            DataStruct.end_blk      = blk_ends[ipath]
            DataStruct.end_date_gmt = STRING(FORMAT=date_fmt, julian2_gmt)
            DataStruct.end_time_gmt = STRING(FORMAT=time_fmt, julian2_gmt)
            DataStruct.end_date_loc = STRING(FORMAT=date_fmt, julian2_loc)
            DataStruct.end_time_loc = STRING(FORMAT=time_fmt, julian2_loc)

            DataList = [DataList, DataStruct]
            norbit += 1
         ENDIF

      ENDFOR
   ENDFOR

   total_orbits += norbit

   ;------------------------------------------------------------------------
   ; Do some post-processing of the orbit data.
   ;------------------------------------------------------------------------

   OrbitList = ''

   IF (norbit GT 0) THEN BEGIN

      DataList = DataList[1:norbit]

      ;---------------------------------------------------------------------
      ; Sort the data by orbit number.
      ;---------------------------------------------------------------------

      sort_ndx = SORT(DataList[*].orbit)
      DataList = DataList[sort_ndx]

      ;---------------------------------------------------------------------
      ; Construct a comma-separated list of orbits.
      ;---------------------------------------------------------------------

      FOR icnt=0,norbit-1 DO BEGIN
         OrbitList += STRTRIM(STRING(DataList[icnt].orbit),2) + ','
      ENDFOR

      nlen = STRLEN(OrbitList)
      OrbitList = STRMID(OrbitList,0, nlen-1)

   ENDIF

   ;------------------------------------------------------------------------
   ; Print the results to file unless we're ordering data (not ready yet).
   ;------------------------------------------------------------------------

   IF (~ForOrder) THEN BEGIN

      ;---------------------------------------------------------------------
      ; Print the header information.
      ;---------------------------------------------------------------------

      dashes = '--------------------------------'
      PRINTF, rpt_unit, dashes + dashes
      PRINTF, rpt_unit, dashes + dashes

      PRINTF, rpt_unit, 'Search number    : ' + STRTRIM(STRING(iobj+1),2)

      PRINTF, rpt_unit, 'Input date range : ' + beg_date + ' to ' + end_date

      PRINTF, rpt_unit, 'Input lat range  : ' + $
              STRING(FORMAT='(F9.3)', LL_list[0, iobj]) + '  to ' + $
              STRING(FORMAT='(F9.3)', LL_list[1, iobj])

      PRINTF, rpt_unit, 'Input lon range  : ' + $
              STRING(FORMAT='(F9.3)', LL_list[2, iobj]) + ' to ' + $
              STRING(FORMAT='(F9.3)', LL_list[3, iobj])

      ;---------------------------------------------------------------------
      ; Print the comma-separated list of orbit numbers.
      ;---------------------------------------------------------------------

      PRINTF, rpt_unit, ''
      PRINTF, rpt_unit, 'List of Orbits satisfying search criteria :'
      PRINTF, rpt_unit, OrbitList

      ;---------------------------------------------------------------------
      ; Print a table with details about each orbit.
      ;---------------------------------------------------------------------

      PRINTF, rpt_unit, ''
      PRINTF, rpt_unit, 'Orbit  Path  Blk   GMT Date    GMT Time   ' + $ 
              'Local Date  Local Time'
      PRINTF, rpt_unit, '-----  ----  ---  ----------  ----------  ' + $
              '----------  ----------'

      ;---------------------------------------------------------------------
      ; Print the data table, 2 records per orbit: beg and end block numbers
      ; and overpass times in GMT and local format.
      ;---------------------------------------------------------------------

      IF (norbit LT 1) THEN BEGIN
         PRINTF, rpt_unit, 'No orbits were found for these time and ' + $
                           'geographic coordinates.'
      ENDIF ELSE BEGIN
         FOR icnt=0,norbit-1 DO BEGIN
            PRINTF, rpt_unit, FORMAT= $
                    '(I5,I6,I5,2X,A10,2X,A9,2X,A11,2X,A9)', $
                    DataList[icnt].orbit, $
                    DataList[icnt].path, $
                    DataList[icnt].beg_blk, $
                    DataList[icnt].beg_date_gmt, $
                    DataList[icnt].beg_time_gmt, $
                    DataList[icnt].beg_date_loc, $
                    DataList[icnt].beg_time_loc

            PRINTF, rpt_unit, FORMAT= $
                    '(11X,I5,2X,A10,2X,A9,2X,A11,2X,A9)', $
                    DataList[icnt].end_blk, $
                    DataList[icnt].end_date_gmt, $
                    DataList[icnt].end_time_gmt, $
                    DataList[icnt].end_date_loc, $
                    DataList[icnt].end_time_loc
         ENDFOR
      ENDELSE

      PRINTF, rpt_unit, ''
      PRINTF, rpt_unit, ''
   ENDIF

   ;------------------------------------------------------------------------
   ; This section is for debugging.
   ;------------------------------------------------------------------------

   IF (DEBUG_ON) THEN BEGIN
      blk_ary = INTARR(4)
      LatList = FLTARR(5)
      LonList = FLTARR(5)

      FOR icnt=0,norbit-1 DO BEGIN
         IF (Data_numpts[icnt] GT 1) THEN BEGIN
            FOR ipt=0,3 DO BEGIN
               blk_ary[ipt] = Data_blok[icnt+ipt]
            ENDFOR
            LatList[0] = Data_latval[icnt+3]
            LatList[1] = Data_latval[icnt+2]
            LatList[2] = Data_latval[icnt+0]
            LatList[3] = Data_latval[icnt+1]
            LatList[4] = Data_latval[icnt+3]
            LonList[0] = Data_lonval[icnt+3]
            LonList[1] = Data_lonval[icnt+2]
            LonList[2] = Data_lonval[icnt+0]
            LonList[3] = Data_lonval[icnt+1]
            LonList[4] = Data_lonval[icnt+3]
            BlockBeg = (MIN(blk_ary) - 5) > 1
            BlockEnd = (MAX(blk_ary) + 5) < !KON.Instr.NUM_BLOCKS
            icnt += 3
         ENDIF ELSE BEGIN
            BlockBeg = (Data_blok[icnt] - 5) > 1
            BlockEnd = (Data_blok[icnt] + 5) < !KON.Instr.NUM_BLOCKS
            LatList[0] = Data_latval[icnt]
            LonList[0] = Data_lonval[icnt]
         ENDELSE

         OverpassShowLocation, Data_path[icnt], Data_orbit[icnt], $
                               Data_numpts[icnt], Data_date_L[icnt], $
                               Data_time_L[icnt], 0, BlockBeg, BlockEnd, $
                               LonList, LatList, MapWndw, $
                               !VAR.CurrFiles.OverpassFile, rtrn_val

      IF (rtrn_val EQ -1) THEN BREAK
      ENDFOR
   ENDIF

   ;------------------------------------------------------------------------
   ; Delete the array of data structures for this object.
   ;------------------------------------------------------------------------

   DataList  = 0
   orbit_cnt = 0

ENDFOR

;SafeWDELETE, wndw_work, didit

IF (~ForOrder) THEN BEGIN
   FREE_LUN, rpt_unit
   rtrn_val = ChmodCatchError(ReportFile, '666'O)
ENDIF

;---------------------------------------------------------------------------
; Tell the user where the file is and clean up.
;---------------------------------------------------------------------------

IF (total_orbits LT 1) THEN BEGIN
   mssg = 'No orbits were found matching your requirements.'
   rtrn = DIALOG_MESSAGE(mssg, /CENTER, /INFORMATION)
   GOTO, nextpass
ENDIF ELSE BEGIN
   IF (~ForOrder) THEN BEGIN
      mssg = [STRTRIM(STRING(total_orbits),2) + $
              ' orbits were found matching your requirements.', $
              ' ', 'Your output file is located at:', ReportFile, $
              ' ', 'Do you wish to create maps showing the locations', $
              'you have selected for each successful MISR orbits?']
      rtrn = DIALOG_MESSAGE(mssg, /CENTER, /QUESTION)
   ENDIF ELSE BEGIN
;      mssg = STRTRIM(STRING(total_orbits),2) + $
;              ' orbits were found matching your requirements.'
;      rtrn = DIALOG_MESSAGE(mssg, /CENTER, /INFO)
   ENDELSE
ENDELSE

;---------------------------------------------------------------------------
; Give the user the oportunity to display maps of selected orbits with the
; point/region highlighted. Read the data from the file just created. This
; is a stopgap - later allow user to select any file and read its data.
;---------------------------------------------------------------------------

iorbits = 0

IF (~ForOrder AND STRUPCASE(rtrn) EQ 'YES') THEN BEGIN

   LatList = FLTARR(5)
   LonList = FLTARR(5)

   ;------------------------------------------------------------------------
   ; Read the available orbits from file.
   ;------------------------------------------------------------------------

   GetOrbitsFromFile, ReportFile, LatBeg, LatEnd, LonBeg, LonEnd, BlkBeg, $
                      BlkEnd, LocDateB, LocTimeB, LocDateE, LocTimeE, $
                      PathList, Orbit_list, NumOrbits, RegionNums, Retval

   IF (Retval EQ -1) THEN BEGIN
      mssg = 'Could not display data for '
      rtrn = DIALOG_MESSAGE(mssg, /CENTER, /ERROR)
      GOTO, nextpass
   ENDIF

   icontinue = 1
   IsDone = INTARR(NumOrbits)

   WHILE (icontinue) DO BEGIN
      LatList[*] = -999.
      LonList[*] = -999.

      ;---------------------------------------------------------------------
      ; Display the orbits in a GUI and select an orbit.
      ;---------------------------------------------------------------------

      IF (USER_SELECT_PNG EQ 1) THEN BEGIN
         GetOrbitNumber_gui, Orbit_list, OrbitSel, Retval
         IF (Retval EQ -1) THEN BEGIN
            mssg = 'Do you want to quit viewing maps?'
            rtrn = DIALOG_MESSAGE(mssg, /CENTER, /QUESTION)
            IF (STRUPCASE(rtrn) EQ 'YES') THEN BEGIN
               SafeWDELETE, MapWndw, didit
               GOTO, nextpass
            ENDIF ELSE BEGIN
               CONTINUE
            ENDELSE
         ENDIF
      ENDIF ELSE BEGIN
         IF (iorbits EQ total_orbits) THEN BEGIN
            SafeWDELETE, MapWndw, didit
            GOTO, nextpass
         ENDIF
         OrbitSel = Orbit_list[iorbits]
         iorbits += 1
      ENDELSE

      ;---------------------------------------------------------------------
      ; Get data for the selected orbit loaded from the file.
      ;---------------------------------------------------------------------

      nCorner = 0
      iorbit_num = 0

      FOR item=0,NumOrbits-1 DO BEGIN
         IF (Orbit_list[item] EQ OrbitSel AND IsDone[item] NE 1) THEN BEGIN
            IsDone[item] = 1
            RegNum   = RegionNums[item]
            PathNum  = PathList[item]
            BlockBeg = BlkBeg[item]
            BlockEnd = BlkEnd[item]
            begdate  = LocDateB[item]
            begtime  = LocTimeB[item]
            enddate  = LocDateE[item]
            endtime  = LocTimeE[item]
            IF (LatEnd[item] EQ LatBeg[item] AND $
                LonEnd[item] EQ LonBeg[item]) THEN BEGIN
               LatList[0] = LatBeg[item]
               LonList[0] = LonBeg[item]
               nCorner = 1
            ENDIF ELSE BEGIN
               LatList[0] = LatBeg[item]
               LatList[1] = LatBeg[item]
               LatList[2] = LatEnd[item]
               LatList[3] = LatEnd[item]
               LatList[4] = LatBeg[item]
               LonList[0] = LonBeg[item]
               LonList[1] = LonEnd[item]
               LonList[2] = LonEnd[item]
               LonList[3] = LonBeg[item]
               LonList[4] = LonBeg[item]
               nCorner = 4
            ENDELSE
            iorbit_num += 1
            BREAK
         ENDIF
      ENDFOR

      IF (nCorner EQ 0) THEN BEGIN
         mssg = ['Could not extract geographic coordinates', $
                 'for your point(s) on orbit ' + OrbitSel]
         rtrn = DIALOG_MESSAGE(mssg, /CENTER, /ERROR)
      ENDIF

      ;---------------------------------------------------------------------
      ; Display the data.
      ;---------------------------------------------------------------------

      nBlk = BlockEnd - BlockBeg + 1

      IF (nBlk LT 4) THEN BlockEnd += 1
      IF (nBlk LT 3) THEN BlockBeg -= 1
      IF (nBlk LT 2) THEN BlockEnd += 1

      IF (BlockBeg LT 1) THEN BEGIN
         BlockBeg += 1
         BlockEnd += 1
      ENDIF
      IF (BlockEnd GT 180) THEN BEGIN
         BlockBeg -= nBlk - 2
         BlockEnd -= nBlk - 2
      ENDIF

      OverpassShowLocation, PathNum, OrbitSel, nCorner, begdate, begtime, $
                            RegNum, BlockBeg, BlockEnd, LonList, LatList, $
                            MapWndw, !VAR.CurrFiles.OverpassFile, rtrn_val
      IF (rtrn_val EQ -1) THEN BEGIN
         SafeWDELETE, MapWndw, didit
         GOTO, nextpass
      ENDIF

   ENDWHILE

ENDIF

LocDate = 0
LocTime = 0
BlkBeg  = 0
BlkEnd  = 0
LatList = 0
LonList = 0
PathList = 0
RegionNums = 0
Orbit_list = 0

Status = 0

END  ;  OverpassFinder
